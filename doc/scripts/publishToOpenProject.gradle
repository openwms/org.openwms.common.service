buildscript {
    repositories {
        mavenCentral()
        maven {
            credentials {
                username mavenUsername
                password mavenPassword
            }
            url mavenRepository
        }
    }
    dependencies {
        classpath 'org.apache.httpcomponents:httpmime:4.5.1'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
        classpath 'org.postgresql:postgresql:42.6.0'
    }
}


import groovyx.net.http.HTTPBuilder
import groovyx.net.http.Method
import org.apache.http.entity.mime.HttpMultipartMode
import org.apache.http.entity.mime.MultipartEntity
import org.apache.http.entity.mime.content.InputStreamBody
import org.apache.http.entity.mime.content.StringBody

import java.nio.file.FileSystems
import java.sql.Driver
import java.util.regex.Pattern

//to upload attachments:

import static groovy.io.FileType.*

//tag::publishToOpenProject[]
task publishToOpenProject(
        description: 'Publish contents as markdown to OpenProject',
        group: 'docToolchain'
) {

    doLast {
        def configFile = new File(docDir, mainConfigFile)
        def config = new ConfigSlurper().parse(configFile.text)

        Map dbConnParams = [
                url: config.openproject.jdbcurl,
                user: config.openproject.user,
                password: config.openproject.password,
                driver: config.openproject.driver
        ]

        Map params = [
                api: config.openproject.api,
                projectId: config.openproject.projectId,
                wikiId: config.openproject.wikiId,
                parentPageId: config.openproject.parentPageId,
                login: config.openproject.authorName,
                dryRun: config.openproject.dryRun
        ]

        def props = new Properties()
        props.setProperty("user", dbConnParams.user)
        props.setProperty("password", dbConnParams.password)

        def driver = Class.forName(dbConnParams.driver).newInstance() as Driver
        def conn = driver.connect(dbConnParams.url, props)
        def sql = new groovy.sql.Sql(conn)
        try {
            def result = sql.rows("SELECT * FROM PROJECTS WHERE ID = :projectId", projectId: params.projectId)
            if (result.empty) {
                println("Project with id ["+params.projectId+"] not found")
                System.exit(1)
            }
            def author = sql.rows("SELECT ID FROM USERS WHERE LOGIN = :login", login: params.login)?.find()
            if (author == null) {
                println("Author with login ["+params.login+"] not found")
                System.exit(1)
            }
            result.each{ rs ->
                def wikis = sql.rows("""
                    SELECT * FROM WIKI_PAGES
                     WHERE PARENT_ID = :parentPageId
                       AND WIKI_ID = :wikiId
                    """,
                        parentPageId: params.parentPageId, wikiId: params.wikiId)
                if (wikis.empty) {
                    println("No wiki pages for project with id ["+params.projectId+"] found")
                    System.exit(1)
                }
                File sourceFolder = new File("${targetDir}/md")
                println "sourceFolder: " + sourceFolder.canonicalPath
                println "targetFolder: " + targetDir
//                println("Delete all content below the parent page")
//                deleteChildren(params.parentPageId, params.wikiId)

                def existingPages = findExistingPages(sql, (int) params.parentPageId)
                sourceFolder.traverse(type: FILES) { file ->
                    if (file.name ==~ '^.*[.](md)$') {
                        def currentFileName = file.canonicalPath.replace("\\", "\\\\")
                        println(currentFileName)
                        def title = createTitle(currentFileName.substring(currentFileName.lastIndexOf(FileSystems.getDefault().getSeparator()) + 1))
                        existingPages.each( page -> {
                            println("${page.id}, ${page.wiki_id}, ${page.title}, ${page.slug}, ${page.parent_id}")
                            if (title == ((String)page.title)) {
                                updatePage(sql, (boolean) params.dryRun, (int) page.id, title, file.text)
//                        replaceImages(config.openproject.api, config.openproject.token, currentFileName, wikiPageId)
                            } else {
//                        def wikiPageId = getNextWikiPageId(sql)
//                        println "Next wikiPageId: ${wikiPageId}"
//                        insertChildPage(sql, (boolean) params.dryRun, (int) params.parentPageId, (int) params.wikiId, (int) wikiPageId, title, (int) author.id, file.text)
//                        replaceImages(config.openproject.api, config.openproject.token, currentFileName, wikiPageId)
                            }
                        }
                        )
                    }
                }
                //println(wikis)
            }
        } finally {
            sql.close()
            conn.close()
        }
    }
}

void replaceImages(api, token, filename, pageId) {
    def fullApi = "${api}/api/v3/wiki_pages/${pageId}/attachments"
    println "Full API: ${fullApi}"
    def http = new HTTPBuilder(fullApi)
    def basicAuth = "Basic " + "apikey:${token}".bytes.encodeBase64().toString()
    File file = new File(filename);
    // !\[(.*?)\]\((.*?)\)
    String content = file.text

    // Define the regular expression for image links
    def imageLinkRegex = /!\[(.*?)\]\((.*?)\)/

    // Find all image links using the regular expression
    def matcher = content =~ imageLinkRegex

    // Iterate over the matches and print them
    matcher.each { match ->
        def altText = match[1]
        def url = match[2]
        println "Found image link: [Alt text: '${altText}', URL: '${url}']"
        uploadImage(http, basicAuth, altText, "${targetDir}/md/${url}")
    }
}

void uploadImage(http, basicAuth, altText, url) {
    http.request(Method.POST) { req -> {
        req.addHeader("ContentType", "multipart/form-data")
        req.addHeader("Authorization", basicAuth)
        MultipartEntity multiPartContent = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE)
        // Adding another string parameter "metadata"
        multiPartContent.addPart("metadata", new StringBody("{\"fileName\":\"${url}\"}"))
        // Adding Multi-part file parameter "file"
        def is = new File(url).newDataInputStream()
        multiPartContent.addPart("file", new InputStreamBody(is, url))
        req.setEntity(multiPartContent)
        headers.each { key, value ->
            req.addHeader(key, value)
        }
    }
    response.success = { resp, json ->
        println "Request successful!"
        println "Response: ${json}"
    }

    response.failure = { resp ->
        println "Request failed with status ${resp.status}!"
    }
    }
}

static String createTitle(filename) {
    filename = filename.substring(0, filename.indexOf('.'))
    String titleString = filename.replaceAll("[_-]", " ");
    def titleWords = Arrays.stream(titleString.split(' '))
            .filter(Objects::nonNull)
            .map(s-> Pattern.compile("^.").matcher(s).replaceFirst(m -> m.group().toUpperCase()))
            .sorted()
            .toList()
    def first = titleWords[0]
    def result = String.join(" ", titleWords)
    if (Character.isDigit(first.charAt(0))) {
        result = result.replaceFirst(first, first + " -")
    }
    return result
}

void deleteChildren(parentPageId, wikiId) {

}

int getNextWikiPageId(groovy.sql.Sql sql) {
    def result = sql.firstRow("SELECT nextval('wiki_pages_id_seq') as wikiPageId")
    return result.wikiPageId
}

List findExistingPages(groovy.sql.Sql sql, int pageId) {
    return sql.rows("SELECT * FROM wiki_pages WHERE parent_id = :pageId", pageId: pageId)
}

void insertChildPage(groovy.sql.Sql sql, boolean dryRun, int parentPageId, int wikiId, int wikiPageId, String title, int authorId, String text) {
    println "Insert new page ${page.title}"
    if (dryRun) {
        println("""
    INSERT INTO wiki_pages (id, wiki_id, title, created_at, protected, parent_id, slug, updated_at, author_id, text, lock_version) VALUES
        (${wikiPageId}, ${wikiId}, ${title}, now(), false, ${parentPageId}, ${UUID.randomUUID().toString()}, now(), ${authorId}, ${text}, 0)
    """
        )
        return
    }
    sql.execute("""
    INSERT INTO wiki_pages (id, wiki_id, title, created_at, protected, parent_id, slug, updated_at, author_id, text, lock_version) VALUES
        (${wikiPageId}, ?, ?, now(), false, ?, ?, now(), ?, ?, 0)
    """, wikiId, title, parentPageId, UUID.randomUUID().toString(), authorId, text);
}

void updatePage(groovy.sql.Sql sql, boolean dryRun, int wikiPageId, String title, String text) {
    println "Existing page needs update ${page.title}"
    if (dryRun) {
        println("""
    UPDATE wiki_pages SET title = ${title}, updated_at = now(), text = ${text} WHERE id = ${wikiPageId})
    """
        )
        return
    }
//    sql.execute("""
//    UPDATE wiki_pages SET title = :title, updated_at = now(), text = :text WHERE id = :id)
//    """, title: title, text: text, id: wikiPageId);
}
//end::publishToOpenProject[]
